"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.schemaToScript = schemaToScript;
const namespaces_js_1 = require("../namespaces.js");
const NAMESPACES = [
    namespaces_js_1.dbo,
    namespaces_js_1.dc,
    namespaces_js_1.dcterms,
    namespaces_js_1.foaf,
    namespaces_js_1.gr,
    namespaces_js_1.ldkit,
    namespaces_js_1.owl,
    namespaces_js_1.rdf,
    namespaces_js_1.rdfs,
    namespaces_js_1.schema,
    namespaces_js_1.sioc,
    namespaces_js_1.skos,
    namespaces_js_1.xsd,
];
function schemaToScript(schemas) {
    const printer = new SchemaPrinter();
    return printer.print(schemas);
}
class SchemaPrinter {
    constructor() {
        Object.defineProperty(this, "usedNamespaces", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Set()
        });
        Object.defineProperty(this, "space", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "  "
        });
    }
    print(schemas) {
        const orderedSchemas = this.orderSchemasByDependencies(schemas);
        const printedSchemas = [];
        for (const schema of orderedSchemas) {
            this.extractNamespaces(schema);
            const printedSchema = this.printSchema(schema);
            printedSchemas.push(printedSchema);
        }
        if (this.usedNamespaces.size > 0) {
            printedSchemas.unshift(this.printImports());
        }
        return printedSchemas.join("\n");
    }
    orderSchemasByDependencies(schemas) {
        const orderedSchemas = [];
        const processedSchemas = new Set();
        const dependencies = schemas.map((schema) => {
            return {
                schemaName: schema.name,
                dependencies: this.getSchemaDependencies(schema),
            };
        });
        let unresolved = schemas.length;
        while (unresolved > 0) {
            let progress = false;
            for (const info of dependencies) {
                if (processedSchemas.has(info.schemaName)) {
                    continue;
                }
                const allDepsProcessed = info.dependencies.every((dep) => processedSchemas.has(dep));
                if (allDepsProcessed) {
                    orderedSchemas.push(schemas.find((schema) => schema.name === info.schemaName));
                    processedSchemas.add(info.schemaName);
                    unresolved--;
                    progress = true;
                }
            }
            if (!progress) {
                throw new Error("Circular dependency detected");
            }
        }
        return orderedSchemas;
    }
    getSchemaDependencies(schema) {
        const dependencies = [];
        for (const property of Object.values(schema.properties)) {
            if (property.schemaRef) {
                dependencies.push(property.schemaRef);
            }
            if (property.schema) {
                dependencies.push(...this.getSchemaDependencies(property.schema));
            }
        }
        return dependencies;
    }
    extractNamespace(value) {
        if (value === "@id") {
            this.usedNamespaces.add(this.printPrefix(namespaces_js_1.ldkit));
            return;
        }
        for (const namespace of NAMESPACES) {
            if (value.startsWith(namespace.$iri)) {
                this.usedNamespaces.add(this.printPrefix(namespace));
                return;
            }
        }
    }
    extractNamespaces(schema) {
        for (const typeValue of schema.type) {
            this.extractNamespace(typeValue);
        }
        for (const property of Object.values(schema.properties)) {
            this.extractNamespace(property.id);
            if (property.type) {
                this.extractNamespace(property.type);
            }
            if (property.schema) {
                this.extractNamespaces(property.schema);
            }
        }
    }
    printImports() {
        const namespacesString = Array.from(this.usedNamespaces)
            .toSorted()
            .join(", ");
        return `import { ${namespacesString} } from "ldkit/namespaces";\n`;
    }
    printSchema(schema) {
        const type = this.printType(schema);
        const properties = this.printProperties(schema);
        return [
            `export const ${schema.name} = {`,
            this.indent(type),
            this.indent(properties),
            `} as const;\n`,
        ].filter(Boolean).join("\n");
    }
    printSubSchema(schema) {
        const type = this.printType(schema);
        const properties = this.printProperties(schema);
        return [
            `"@schema": {`,
            this.indent(type),
            this.indent(properties),
            `},`,
        ].filter(Boolean).join("\n");
    }
    printProperties(schema) {
        if (Object.keys(schema.properties).length === 0) {
            return null;
        }
        return Object.entries(schema.properties)
            .map(([key, prop]) => this.printProperty(key, prop))
            .join("\n");
    }
    printProperty(key, prop) {
        if (!prop.schema && !prop.schemaRef &&
            !prop.optional && !prop.array &&
            !prop.multilang && !prop.inverse &&
            (!prop.type || prop.type === namespaces_js_1.xsd.string)) {
            return `${this.printKey(key)}: ${this.printPrefixed(prop.id)},`;
        }
        const builder = [
            `${this.printKey(key)}: {`,
            this.indent(`"@id": ${this.printPrefixed(prop.id)},`),
        ];
        if (prop.type) {
            builder.push(this.indent(`"@type": ${this.printPrefixed(prop.type)},`));
        }
        if (prop.schema) {
            const subSchema = this.printSubSchema(prop.schema);
            builder.push(this.indent(subSchema));
        }
        else if (prop.schemaRef) {
            builder.push(this.indent(`"@schema": ${prop.schemaRef},`));
        }
        const flags = ["optional", "array", "multilang", "inverse"];
        for (const flag of flags) {
            if (prop[flag]) {
                builder.push(this.indent(`"@${flag}": true,`));
            }
        }
        builder.push("},");
        return builder.join("\n");
    }
    printType(schema) {
        if (schema.type.length === 0) {
            return null;
        }
        if (schema.type.length === 1) {
            return `"@type": ${this.printPrefixed(schema.type[0])},`;
        }
        return [
            `"@type": [`,
            ...schema.type.map((type) => `  ${this.printPrefixed(type)},`),
            `],`,
        ].join("\n");
    }
    printPrefix(namespace) {
        return namespace.$prefix.substring(0, namespace.$prefix.length - 1);
    }
    printPrefixed(value) {
        if (value === "@id") {
            return `${this.printPrefix(namespaces_js_1.ldkit)}.IRI`;
        }
        for (const namespace of NAMESPACES) {
            if (value.startsWith(namespace.$iri)) {
                return `${this.printPrefix(namespace)}.${value.substring(namespace.$iri.length)}`;
            }
        }
        return `"${value}"`;
    }
    printKey(key) {
        if (key.match(/^[a-zA-Z0-9_]+$/)) {
            return key;
        }
        return `"${key}"`;
    }
    indent(text) {
        if (text === null) {
            return null;
        }
        return text.split("\n")
            .map((line) => `${this.space}${line}`)
            .join("\n");
    }
}
