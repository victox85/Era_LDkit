"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.contextToSchema = contextToSchema;
const jsonld_context_parser_1 = require("jsonld-context-parser");
async function contextToSchema(json) {
    const converter = new ContextConverter();
    const schemas = await converter.process(json);
    return schemas;
}
class ContextConverter {
    constructor() {
        Object.defineProperty(this, "parser", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new jsonld_context_parser_1.ContextParser()
        });
        Object.defineProperty(this, "schemaNames", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Set()
        });
        Object.defineProperty(this, "schemas", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
    }
    getSuffix(value) {
        const cutoff = Math.max(value.lastIndexOf("#"), value.lastIndexOf("/"));
        if (cutoff === -1) {
            return value;
        }
        return value.substring(cutoff + 1);
    }
    capitalize(val) {
        return String(val).charAt(0).toUpperCase() + String(val).slice(1);
    }
    generateSchemaName(context, key) {
        const types = context["@type"];
        const wrap = (val) => `${this.capitalize(val)}Schema`;
        if (typeof types === "string") {
            return wrap(this.getSuffix(types));
        }
        else if (Array.isArray(types)) {
            const suffixes = types.map((type) => this.getSuffix(type));
            return wrap(suffixes.join(""));
        }
        return wrap(key);
    }
    generateUniqueSchemaName(context, key) {
        const name = this.generateSchemaName(context, key);
        if (!this.schemaNames.has(name)) {
            this.schemaNames.add(name);
            return name;
        }
        for (let i = 1; i < 100; i++) {
            const newName = `${name}${i}`;
            if (!this.schemaNames.has(newName)) {
                this.schemaNames.add(newName);
                return newName;
            }
        }
        throw new Error("Too many schemas with the same name");
    }
    createSchema(context, key) {
        const name = this.generateUniqueSchemaName(context, key);
        const schema = {
            name,
            type: [],
            properties: {},
        };
        this.schemaNames.add(name);
        this.schemas.push(schema);
        return schema;
    }
    async process(json) {
        const parsed = await this.parser.parse(json, { external: false });
        const context = parsed.getContextRaw();
        const schema = this.createSchema(context, "The");
        await this.processSchema(context, context, schema);
        return this.schemas;
    }
    async processSchema(context, contextFull, schema) {
        const types = context["@type"];
        if (typeof types === "string") {
            schema.type.push(types);
        }
        else if (Array.isArray(types)) {
            for (const type of types) {
                if (typeof type === "string") {
                    schema.type.push(type);
                }
            }
        }
        for (const [key, prop] of Object.entries(context)) {
            if (prop === undefined || prop === null || key.startsWith("@")) {
                // Ignore undefined, null, and special properties
                continue;
            }
            if (typeof prop === "string" &&
                (prop.endsWith("/") || prop.endsWith("#") || prop.startsWith("@"))) {
                // Ignore prefixes and remapping of special properties
                continue;
            }
            if (typeof prop === "string") {
                schema.properties[key] = {
                    id: prop,
                };
                continue;
            }
            if (typeof prop !== "object" || Array.isArray(prop)) {
                // This should not happen, but just in case
                continue;
            }
            schema.properties[key] = await this.processProperty(contextFull, key, prop);
        }
        return schema;
    }
    async processProperty(context, key, prop) {
        const property = {
            id: prop["@id"],
        };
        if (typeof prop["@type"] === "string") {
            property.type = prop["@type"];
        }
        if (prop["@context"] && typeof prop["@context"] === "object") {
            const parsed = await this.parser.parse(prop["@context"], {
                external: false,
                parentContext: context,
            });
            const subcontextFull = parsed.getContextRaw();
            const subcontext = {};
            for (const [key, _value] of Object.entries(prop["@context"])) {
                subcontext[key] = subcontextFull[key];
            }
            const subschema = this.createSchema(subcontext, key);
            await this.processSchema(subcontext, subcontextFull, subschema);
            property.schemaRef = subschema.name;
        }
        const containers = (prop["@container"] || {});
        if (containers["@set"] || containers["@list"]) {
            property.array = true;
        }
        if (containers["@language"]) {
            property.multilang = true;
        }
        if (prop["@reverse"]) {
            property.inverse = true;
        }
        return property;
    }
}
