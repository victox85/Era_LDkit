#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const node_process_1 = require("node:process");
const node_util_1 = require("node:util");
const node_fs_1 = require("node:fs");
const commander_1 = require("commander");
const context_to_schema_js_1 = require("./scripts/context_to_schema.js");
const shex_to_schema_js_1 = require("./scripts/shex_to_schema.js");
const schema_to_script_js_1 = require("./scripts/schema_to_script.js");
const asciiArt = String.raw `
  _     ____  _    _ _   
 | |   |  _ \| | _(_) |_ 
 | |   | | | | |/ / | __|
 | |___| |_| |   <| | |_ 
 |_____|____/|_|\_\_|\__|
                                                              
`;
const program = new commander_1.Command();
program
    .name("ldkit")
    .description("LDkit CLI utilities for Linked Data")
    .helpOption(false)
    .showHelpAfterError()
    .configureHelp({
    styleCommandDescription: (str) => (0, node_util_1.styleText)("gray", str),
    styleDescriptionText: (str) => (0, node_util_1.styleText)("gray", str),
    styleCommandText: (str) => (0, node_util_1.styleText)("cyan", str),
    styleArgumentText: (str) => (0, node_util_1.styleText)("yellow", str),
    styleSubcommandText: (str) => (0, node_util_1.styleText)("cyan", str),
})
    .configureOutput({
    outputError: (str, write) => write((0, node_util_1.styleText)("red", str)),
    stripColor: (str) => str,
});
program.command("context-to-schema")
    .description("Convert a JSON-LD context from a file or URL to a LDkit schema")
    .addArgument(new commander_1.Argument("<method>", "type of input").choices([
    "url",
    "file",
    "arg",
]))
    .argument("<input>", "input JSON-LD context - file, URL, or string")
    .action(async (method, input) => {
    try {
        const resolvedInput = await resolve(method, input);
        const schema = await (0, context_to_schema_js_1.contextToSchema)(JSON.parse(resolvedInput));
        console.log((0, schema_to_script_js_1.schemaToScript)(schema));
    }
    catch (error) {
        console.error((0, node_util_1.styleText)("red", `${error.message}`));
    }
});
program.command("shexc-to-schema")
    .description("Convert a ShExC schema from a file or URL to a LDkit schema")
    .addArgument(new commander_1.Argument("<method>", "type of input").choices([
    "url",
    "file",
    "arg",
]))
    .argument("<input>", "input ShExC schema - file, URL, or string")
    .action(async (method, input) => {
    try {
        const resolvedInput = await resolve(method, input);
        const schema = (0, shex_to_schema_js_1.shexcToSchema)(resolvedInput);
        console.log((0, schema_to_script_js_1.schemaToScript)(schema));
    }
    catch (error) {
        console.error((0, node_util_1.styleText)("red", `${error.message}`));
    }
});
program.command("shexj-to-schema")
    .description("Convert a ShExJ schema from a file or URL to a LDkit schema")
    .addArgument(new commander_1.Argument("<method>", "type of input").choices([
    "url",
    "file",
    "arg",
]))
    .argument("<input>", "input ShExJ schema - file, URL, or string")
    .action(async (method, input) => {
    try {
        const resolvedInput = await resolve(method, input);
        const schema = (0, shex_to_schema_js_1.shexjToSchema)(JSON.parse(resolvedInput));
        console.log((0, schema_to_script_js_1.schemaToScript)(schema));
    }
    catch (error) {
        console.error((0, node_util_1.styleText)("red", `${error.message}`));
    }
});
// Check if no arguments were provided
if (node_process_1.argv.length <= 2) {
    console.log((0, node_util_1.styleText)("red", asciiArt));
    program.help(); // Automatically exits after printing help
}
else {
    program.parse(node_process_1.argv);
}
async function resolve(method, input) {
    if (method === "url") {
        try {
            return await fetch(input).then((res) => res.text());
        }
        catch (error) {
            throw new Error(`Failed to fetch URL: ${input}.\n${error}`);
        }
    }
    else if (method === "file") {
        try {
            return (0, node_fs_1.readFileSync)(input, "utf-8");
        }
        catch (error) {
            throw new Error(`Failed to read file: ${input}.\n${error}`);
        }
    }
    else if (method === "arg") {
        return input;
    }
    throw new Error(`Unknown resolution method: ${method}`);
}
