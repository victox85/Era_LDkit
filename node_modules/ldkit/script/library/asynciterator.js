"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TreeIterator = exports.MappingIterator = exports.ArrayIterator = void 0;
const asynciterator_1 = require("asynciterator");
var asynciterator_2 = require("asynciterator");
Object.defineProperty(exports, "ArrayIterator", { enumerable: true, get: function () { return asynciterator_2.ArrayIterator; } });
Object.defineProperty(exports, "MappingIterator", { enumerable: true, get: function () { return asynciterator_2.MappingIterator; } });
class TreeIterator extends asynciterator_1.AsyncIterator {
    constructor(tree) {
        super();
        Object.defineProperty(this, "_tree", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_pointer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._tree = tree;
        this._pointer = this._buildPointerFromSource(tree);
        this.readable = true;
    }
    read() {
        if (this.closed) {
            return null;
        }
        this._findNextCommonSegment();
        this._findNextLeaf();
        const p = this._pointer;
        if (p.type === "leaf") {
            p.index++;
            if (p.index < p.items.length) {
                return [...p.path, p.items[p.index]];
            }
            if (!p.parent) {
                this.close();
            }
        }
        if (p.type === "node") {
            this.close();
        }
        return null;
    }
    _buildPointerFromSource(tree, path = []) {
        if (tree.constructor === Object && !Array.isArray(tree)) {
            return {
                tree,
                parent: this._pointer,
                type: "node",
                items: Object.keys(tree),
                path,
                index: -1,
            };
        }
        if (Array.isArray(tree)) {
            return {
                parent: this._pointer,
                type: "leaf",
                items: tree,
                path,
                index: -1,
            };
        }
        else {
            throw new Error("Invalid tree specified, expecting arrays in plain objects.");
        }
    }
    _findNextCommonSegment() {
        while (this._pointer.parent !== null) {
            const p = this._pointer;
            if (p.type === "leaf" && p.index < p.items.length - 1) {
                // Points to a leaf that is not yet exhausted
                break;
            }
            if (p.index >= p.items.length - 1 && this._pointer.parent) {
                this._pointer = this._pointer.parent;
            }
            else {
                break;
            }
        }
    }
    _findNextLeaf() {
        while (this._pointer.type !== "leaf") {
            const p = this._pointer;
            p.index++;
            if (p.index >= p.items.length) {
                // no other keys present, the tree is exhausted;
                break;
            }
            const key = p.items[p.index];
            const source = this._pointer.tree[key];
            this._pointer = this._buildPointerFromSource(source, [...p.path, key]);
        }
    }
}
exports.TreeIterator = TreeIterator;
