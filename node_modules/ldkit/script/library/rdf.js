"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuadFactory = exports.BindingsFactory = exports.ReadOnlyBindings = exports.TermFactory = exports.quadsToGraph = exports.N3 = exports.DefaultGraph = exports.DataFactory = exports.toRdf = exports.fromRdf = void 0;
var rdf_literal_1 = require("rdf-literal");
Object.defineProperty(exports, "fromRdf", { enumerable: true, get: function () { return rdf_literal_1.fromRdf; } });
Object.defineProperty(exports, "toRdf", { enumerable: true, get: function () { return rdf_literal_1.toRdf; } });
const rdf_string_1 = require("rdf-string");
const rdf_data_factory_1 = require("rdf-data-factory");
Object.defineProperty(exports, "DataFactory", { enumerable: true, get: function () { return rdf_data_factory_1.DataFactory; } });
Object.defineProperty(exports, "DefaultGraph", { enumerable: true, get: function () { return rdf_data_factory_1.DefaultGraph; } });
exports.N3 = __importStar(require("n3"));
const quadsToGraph = (quadStream) => {
    return new Promise((resolve, reject) => {
        const graph = new Map();
        const included = {};
        quadStream.on("data", (quad) => {
            const hash = Object.values((0, rdf_string_1.quadToStringQuad)(quad)).join(" ");
            if (included[hash]) {
                return;
            }
            included[hash] = true;
            const s = quad.subject.value;
            const p = quad.predicate.value;
            const predicateMap = graph.get(s) || graph.set(s, new Map()).get(s);
            const termArray = predicateMap.get(p) || predicateMap.set(p, []).get(p);
            termArray.push(quad.object);
        });
        quadStream.on("end", () => resolve(graph));
        quadStream.on("error", reject);
    });
};
exports.quadsToGraph = quadsToGraph;
class TermFactory {
    constructor(dataFactory = new rdf_data_factory_1.DataFactory()) {
        Object.defineProperty(this, "dataFactory", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.dataFactory = dataFactory;
    }
    fromJson(jsonTerm) {
        if (jsonTerm.type === "uri") {
            return this.dataFactory.namedNode(jsonTerm.value);
        }
        if (jsonTerm.type === "bnode") {
            return this.dataFactory.blankNode(jsonTerm.value);
        }
        if ("lang" in jsonTerm) {
            return this.dataFactory.literal(jsonTerm.value, jsonTerm["lang"]);
        }
        if ("datatype" in jsonTerm) {
            return this.dataFactory.literal(jsonTerm.value, this.dataFactory.namedNode(jsonTerm.datatype));
        }
        return this.dataFactory.literal(jsonTerm.value);
    }
}
exports.TermFactory = TermFactory;
class ReadOnlyBindings {
    constructor(bindings, dataFactory = new rdf_data_factory_1.DataFactory()) {
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "bindings"
        });
        Object.defineProperty(this, "dataFactory", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "entries", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "variables", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.entries = bindings;
        this.dataFactory = dataFactory;
        this.variables = new Map();
        for (const variable of bindings.keys()) {
            this.variables.set(variable.value, variable);
        }
    }
    has(key) {
        const stringKey = typeof key === "string" ? key : key.value;
        const variableKey = this.variables.get(stringKey);
        return this.entries.has(variableKey);
    }
    get(key) {
        const stringKey = typeof key === "string" ? key : key.value;
        const variableKey = this.variables.get(stringKey);
        return this.entries.get(variableKey);
    }
    set(_key, _value) {
        throw new Error("Method not implemented.");
    }
    delete(_key) {
        throw new Error("Method not implemented.");
    }
    keys() {
        return this.entries.keys();
    }
    values() {
        return this.entries.values();
    }
    forEach(fn) {
        return this.entries.forEach(fn);
    }
    get size() {
        return this.entries.size;
    }
    [Symbol.iterator]() {
        return this.entries.entries();
    }
    equals(_other) {
        throw new Error("Method not implemented.");
    }
    filter(_fn) {
        throw new Error("Method not implemented.");
    }
    map(_fn) {
        throw new Error("Method not implemented.");
    }
    merge(_other) {
        throw new Error("Method not implemented.");
    }
    mergeWith(_merger, _other) {
        throw new Error("Method not implemented.");
    }
}
exports.ReadOnlyBindings = ReadOnlyBindings;
class BindingsFactory {
    constructor(dataFactory = new rdf_data_factory_1.DataFactory(), termFactory = new TermFactory(dataFactory)) {
        Object.defineProperty(this, "dataFactory", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "termFactory", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.dataFactory = dataFactory;
        this.termFactory = termFactory;
    }
    fromJson(jsonBindings) {
        const bindingsEntries = Object.entries(jsonBindings).map(([varName, jsonTerm]) => {
            return [
                this.dataFactory.variable(varName),
                this.termFactory.fromJson(jsonTerm),
            ];
        });
        return new ReadOnlyBindings(new Map(bindingsEntries), this.dataFactory);
    }
}
exports.BindingsFactory = BindingsFactory;
class QuadFactory {
    constructor(dataFactory = new rdf_data_factory_1.DataFactory(), termFactory = new TermFactory(dataFactory)) {
        Object.defineProperty(this, "dataFactory", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "termFactory", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.dataFactory = dataFactory;
        this.termFactory = termFactory;
    }
    fromJson(jsonRdf) {
        const [s, p, o] = jsonRdf;
        return this.dataFactory.quad(this.dataFactory.namedNode(s), this.dataFactory.namedNode(p), this.termFactory.fromJson(o));
    }
}
exports.QuadFactory = QuadFactory;
