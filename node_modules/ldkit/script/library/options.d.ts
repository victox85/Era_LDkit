import { type IQueryEngine, type QueryContext } from "./engine/mod.js";
/**
 * LDkit options and query engine context
 *
 * LDkit-specific options are:
 * - `engine` - a query engine to use for querying data sources
 * - `language` - a preferred language for literals
 * - `take` - a default number of results to take (limit of SELECT queries)
 * - `logQuery` - a function that will be called for each SPARQL query
 */
export type Options = {
    engine?: IQueryEngine;
    language?: string;
    take?: number;
    logQuery?: (query: string) => void;
} & Partial<QueryContext>;
/**
 * Sets global configuration {@link Options} for LDkit that will be used
 * by default in all queries, unless overridden in {@link Lens}.
 *
 * LDkit-specific options are:
 * - `engine` - a query engine to use for querying data sources
 * - `language` - a preferred language for literals
 * - `take` - a default number of results to take (limit of SELECT queries)
 * - `logQuery` - a function that will be called for each SPARQL query
 *
 * Default values for these options are:
 * ```typescript
 * const defaultOptions = {
 *   engine: new QueryEngine(),
 *   take: 1000,
 *   logQuery: () => {},
 * };
 * ```
 * The default configuration uses built-in {@link QueryEngine}. Language is not set by default.
 *
 * @param options LDkit options and query engine context
 */
export declare function setGlobalOptions(options: Options): void;
export declare function resolveOptions(options?: Options): {
    engine: IQueryEngine;
    language?: string;
    take: number;
    logQuery: (query: string) => void;
    queryFormat?: import("@rdfjs/types").QueryFormat;
    baseIRI?: string;
    queryTimestamp?: Date;
    sources?: [import("@comunica/types").QuerySourceUnidentified, ...import("@comunica/types").QuerySourceUnidentified[]] | undefined;
    destination?: import("@comunica/types").IDataDestination;
    initialBindings?: import("@rdfjs/types").Bindings;
    log?: import("@comunica/types").Logger;
    datetime?: Date;
    httpProxyHandler?: import("@comunica/types").IProxyHandler;
    lenient?: boolean;
    httpIncludeCredentials?: boolean;
    httpAuth?: string;
    httpTimeout?: number;
    httpBodyTimeout?: boolean;
    httpRetryCount?: number;
    httpRetryDelayFallback?: number;
    httpRetryDelayLimit?: number;
    fetch?: typeof fetch;
    readOnly?: boolean;
    extensionFunctionCreator?: (functionNamedNode: import("@rdfjs/types").NamedNode) => ((args: import("@rdfjs/types").Term[]) => Promise<import("@rdfjs/types").Term>) | undefined;
    functionArgumentsCache?: import("@comunica/types").FunctionArgumentsCache;
    extensionFunctions?: Record<string, (args: import("@rdfjs/types").Term[]) => Promise<import("@rdfjs/types").Term>>;
    explain?: import("@comunica/types").QueryExplainMode;
    recoverBrokenLinks?: boolean;
    distinctConstruct?: boolean;
};
export declare function resolveQueryContext(options: Options): QueryContext;
//# sourceMappingURL=options.d.ts.map