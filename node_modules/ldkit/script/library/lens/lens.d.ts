import type { IRI, RDF } from "../rdf.js";
import { type Options } from "../options.js";
import { type Identity, type Schema, type SchemaInterface, type SchemaSearchInterface, type SchemaUpdateInterface } from "../schema/mod.js";
import type { Entity, Unite } from "./types.js";
/**
 * Creates an instance of Lens that lets you query and update RDF data
 * via data schema using TypeScript native data types.
 *
 * In order to create a Lens instance, you need to provide a data schema
 * that describes the data model which serves to translate data between
 * Linked Data and TypeScript native types (see {@link Schema} for details).
 *
 * You can also pass a set of options for LDkit and a query engine that
 * specify the data source, preferred language, etc. (see {@link Options} for details).
 *
 * @example
 * ```typescript
 * import { createLens, type Options } from "ldkit";
 * import { dbo, rdfs, xsd } from "ldkit/namespaces";
 *
 * // Create options for query engine
 * const options: Options = {
 *   sources: ["https://dbpedia.org/sparql"], // SPARQL endpoint
 *   language: "en", // Preferred language
 * };
 *
 * // Create a schema
 * const PersonSchema = {
 *   "@type": dbo.Person,
 *   name: rdfs.label,
 *   abstract: dbo.abstract,
 *   birthDate: {
 *     "@id": dbo.birthDate,
 *     "@type": xsd.date,
 *   },
 * } as const;
 *
 * // Create a resource using the data schema and options above
 * const Persons = createLens(PersonSchema, options);
 *
 * // List some persons
 * const persons = await Persons.find({ take: 10 });
 * for (const person of persons) {
 *   console.log(person.name); // string
 *   console.log(person.birthDate); // Date
 * }
 *
 * // Get a particular person identified by IRI
 * const ada = await Persons.findByIri("http://dbpedia.org/resource/Ada_Lovelace");
 * console.log(ada?.name); // string "Ada Lovelace"
 * console.log(ada?.birthDate); // Date object of 1815-12-10
 * ```
 *
 * @param schema data schema which extends {@link Schema}
 * @param options optional {@link Options} - contains LDkit and query engine configuration
 * @returns Lens instance that provides interface to Linked Data based on the schema
 */
export declare function createLens<T extends Schema>(schema: T, options?: Options): Lens<T>;
/**
 * Lens provides an interface to Linked Data based on the data schema.
 *
 * For the best developer experience, use the {@link createLens} function to create the instance.
 */
export declare class Lens<T extends Schema> {
    private readonly schema;
    private readonly options;
    private readonly engine;
    private readonly queryBuilder;
    constructor(schema: T, options?: Options);
    private decode;
    private log;
    /**
     * Returns the total number of entities corresponding to the data schema.
     * Optionally, you can specify search criteria and a maximum number of results to count.
     *
     * @example
     * ```typescript
     * import { createLens } from "ldkit";
     * import { schema } from "ldkit/namespaces";
     *
     * // Create a schema
     * const PersonSchema = {
     *   "@type": schema.Person,
     *   name: schema.name,
     * } as const;
     *
     * // Create a resource using the data schema above
     * const Persons = createLens(PersonSchema);
     *
     * // Count all persons
     * const count = await Persons.count(); // number
     *
     * // Count all persons with name that starts with "Ada"
     * const adaCount = await Persons.count({
     *   where: {
     *     name: { $strStarts: "Ada" },
     *   },
     * });
     *
     * // Count all persons, but limit the result to 100
     * const limitedCount = await Persons.count({ max: 100 });
     * ```
     *
     * @param options Search criteria and maximum number of results to count
     * @returns total number of entities corresponding to the data schema
     */
    count(options?: {
        where?: SchemaSearchInterface<T>;
        max?: number;
    }): Promise<number>;
    /**
     * Find entities with a custom SPARQL query.
     *
     * The query must be a CONSTRUCT query, and the root nodes must be of type `ldkit:Resource`.
     * So that the decoder can decode the results, the query must also return all properties
     * according to the data schema.
     *
     * @example
     * ```typescript
     * import { createLens } from "ldkit";
     * import { ldkit, schema } from "ldkit/namespaces";
     * import { CONSTRUCT } from "ldkit/sparql";
     *
     * // Create a schema
     * const PersonSchema = {
     *   "@type": schema.Person,
     *   name: schema.name,
     * } as const;
     *
     * // Create a resource using the data schema above
     * const Persons = createLens(PersonSchema);
     *
     * // Query to find all persons named "Doe"
     * const query = CONSTRUCT`?s a <${ldkit.Resource}>; <${schema.name}> ?name`
     *   .WHERE`?s <${schema.name}> ?name; <${schema.familyName}> "Doe"`.build();
     *
     * // Find all persons that match the custom query
     * const doePersons = await Persons.query(query);
     * ```
     *
     * @param sparqlConstructQuery CONSTRUCT SPARQL query
     * @returns Found entities
     */
    query(sparqlConstructQuery: string): Promise<Unite<SchemaInterface<T>>[]>;
    /**
     * Find entities that match the given search criteria.
     *
     * The search criteria is a JSON object that may contain properties from the data schema.
     * In addition you can specify how many results to return and how many to skip
     * for pagination purposes.
     *
     * @example
     * ```typescript
     * import { createLens } from "ldkit";
     * import { schema } from "ldkit/namespaces";
     *
     * // Create a schema
     * const PersonSchema = {
     *   "@type": schema.Person,
     *   name: schema.name,
     * } as const;
     *
     * // Create a resource using the data schema above
     * const Persons = createLens(PersonSchema);
     *
     * // Find 100 persons with name that starts with "Ada"
     * const persons = await Persons.find({
     *   where: {
     *     name: { $strStarts: "Ada" },
     *   },
     *   take: 100,
     * });
     * ```
     *
     * @param options Search criteria and pagination options
     * @returns entities that match the given search criteria
     */
    find(options?: {
        where?: SchemaSearchInterface<T> | string | RDF.Quad[];
        take?: number;
        skip?: number;
    }): Promise<Unite<SchemaInterface<T>>[]>;
    /**
     * Find one entity that matches the given search criteria.
     *
     * The search criteria is a JSON object that may contain properties from the data schema.
     *
     * @example
     * ```typescript
     * import { createLens } from "ldkit";
     * import { schema } from "ldkit/namespaces";
     *
     * // Create a schema
     * const PersonSchema = {
     *   "@type": schema.Person,
     *   name: schema.name,
     * } as const;
     *
     * // Create a resource using the data schema above
     * const Persons = createLens(PersonSchema);
     *
     * // Find one person with name that starts with "Ada"
     * const person = await Persons.findOne({
     *   name: { $strStarts: "Ada" },
     * });
     * ```
     *
     * @param options Search criteria and pagination options
     * @returns entities that match the given search criteria
     */
    findOne(where?: SchemaSearchInterface<T>): Promise<Unite<SchemaInterface<T>> | null>;
    /**
     * Find a single entity that matches the given IRI.
     *
     * @example
     * ```typescript
     * import { createLens } from "ldkit";
     * import { schema } from "ldkit/namespaces";
     *
     * // Create a schema
     * const PersonSchema = {
     *   "@type": schema.Person,
     *   name: schema.name,
     * } as const;
     *
     * // Create a resource using the data schema above
     * const Persons = createLens(PersonSchema);
     *
     * // Get a particular person identified by IRI
     * const ada = await Persons.findByIri("http://dbpedia.org/resource/Ada_Lovelace");
     * console.log(ada?.name); // string "Ada Lovelace"
     * ```
     *
     * @param iri IRI of the entity to find
     * @returns Entity if found, null otherwise
     */
    findByIri(iri: IRI): Promise<Unite<SchemaInterface<T>> | null>;
    /**
     * Find entities that match the given IRIs.
     *
     * @example
     * ```typescript
     * import { createLens } from "ldkit";
     * import { schema } from "ldkit/namespaces";
     *
     * // Create a schema
     * const PersonSchema = {
     *   "@type": schema.Person,
     *   name: schema.name,
     * } as const;
     *
     * // Create a resource using the data schema above
     * const Persons = createLens(PersonSchema);
     *
     * // Get specific persons identified by IRIs
     * const matches = await Persons.findByIris([
     *   "http://dbpedia.org/resource/Ada_Lovelace",
     *   "http://dbpedia.org/resource/Alan_Turing"
     * ]);
     * console.log(matches[0].name); // string "Ada Lovelace"
     * console.log(matches[1].name); // string "Alan Turing"
     * ```
     *
     * @param iris IRIs of the entities to find
     * @returns Array of found entities, empty array if there are no matches
     */
    findByIris(iris: IRI[]): Promise<Unite<SchemaInterface<T>>[]>;
    private updateQuery;
    /**
     * Inserts one or more entities to the data store.
     *
     * @example
     * ```typescript
     * import { createLens } from "ldkit";
     * import { schema } from "ldkit/namespaces";
     *
     * // Create a schema
     * const PersonSchema = {
     *   "@type": schema.Person,
     *   name: schema.name,
     * } as const;
     *
     * // Create a resource using the data schema above
     * const Persons = createLens(PersonSchema);
     *
     * // Insert a new person
     * await Persons.insert({
     *   $id: "http://example.org/Alan_Turing",
     *   name: "Alan Turing",
     * });
     * ```
     *
     * @param entities Entities to insert
     * @returns Nothing
     */
    insert(...entities: Entity<SchemaInterface<T>>[]): Promise<void>;
    /**
     * Inserts raw RDF quads to the data store.
     *
     * This method is useful when you need to insert data that is not covered by the data schema.
     *
     * @example
     * ```typescript
     * import { createLens } from "ldkit";
     * import { schema } from "ldkit/namespaces";
     * import { DataFactory } from "ldkit/rdf";
     *
     * // Create a schema
     * const PersonSchema = {
     *   "@type": schema.Person,
     *   name: schema.name,
     * } as const;
     *
     * // Create a resource using the data schema above
     * const Persons = createLens(PersonSchema);
     *
     * // Create a custom quad to insert
     * const df = new DataFactory();
     * const quad = df.quad(
     *   df.namedNode("http://example.org/Alan_Turing"),
     *   df.namedNode("http://schema.org/name"),
     *   df.literal("Alan Turing"),
     * );
     *
     * // Insert the quad
     * await Persons.insertData(quad);
     * ```
     *
     * @param quads Quads to insert to the data store
     * @returns Nothing
     */
    insertData(...quads: RDF.Quad[]): Promise<void>;
    /**
     * Updates one or more entities in the data store.
     *
     * @example
     * ```typescript
     * import { createLens } from "ldkit";
     * import { schema } from "ldkit/namespaces";
     *
     * // Create a schema
     * const PersonSchema = {
     *   "@type": schema.Person,
     *   name: schema.name,
     * } as const;
     *
     * // Create a resource using the data schema above
     * const Persons = createLens(PersonSchema);
     *
     * // Update Alan Turing's name
     * await Persons.update({
     *   $id: "http://example.org/Alan_Turing",
     *   name: "Not Alan Turing",
     * });
     * ```
     *
     * @param entities Partial entities to update
     * @returns Nothing
     */
    update(...entities: SchemaUpdateInterface<T>[]): Promise<void>;
    /**
     * Deletes one or more entities from the data store.
     *
     * This method accepts IRIs of the entities to delete and attemps
     * to delete all triples from the database that corresponds to
     * the data schema. Other triples that are not covered by the data
     * schema will not be deleted.
     *
     * If you need to have more control of what triples to delete,
     * use {@link deleteData} instead.
     *
     * @example
     * ```typescript
     * import { createLens } from "ldkit";
     * import { schema } from "ldkit/namespaces";
     *
     * // Create a schema
     * const PersonSchema = {
     *   "@type": schema.Person,
     *   name: schema.name,
     * } as const;
     *
     * // Create a resource using the data schema above
     * const Persons = createLens(PersonSchema);
     *
     * // Delete a person
     * await Persons.delete("http://example.org/Alan_Turing");
     * ```
     *
     * @param identities Identities or IRIs of the entities to delete
     * @returns Nothing
     */
    delete(...identities: Identity[] | IRI[]): Promise<void>;
    /**
     * Deletes raw RDF quads from the data store.
     *
     * This method is useful when you need to delete data that is not covered by the data schema.
     *
     * @example
     * ```typescript
     * import { createLens } from "ldkit";
     * import { schema } from "ldkit/namespaces";
     * import { DataFactory } from "ldkit/rdf";
     *
     * // Create a schema
     * const PersonSchema = {
     *   "@type": schema.Person,
     *   name: schema.name,
     * } as const;
     *
     * // Create a resource using the data schema and context above
     * const Persons = createLens(PersonSchema);
     *
     * // Create a custom quad to insert
     * const df = new DataFactory();
     * const quad = df.quad(
     *   df.namedNode("http://example.org/Alan_Turing"),
     *   df.namedNode("http://schema.org/name"),
     *   df.literal("Alan Turing"),
     * );
     *
     * // Delete the quad
     * await Persons.deleteData(quad);
     * ```
     *
     * @param quads Quads to delete from the data store
     * @returns Nothing
     */
    deleteData(...quads: RDF.Quad[]): Promise<void>;
}
//# sourceMappingURL=lens.d.ts.map