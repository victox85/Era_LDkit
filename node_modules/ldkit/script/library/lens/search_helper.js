"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchHelper = void 0;
const rdf_js_1 = require("../rdf.js");
const mod_js_1 = require("../sparql/mod.js");
const encoder_js_1 = require("../encoder.js");
const xsd_js_1 = require("../../namespaces/xsd.js");
class SearchHelper {
    constructor(property, varName, searchSchema) {
        Object.defineProperty(this, "property", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "propertyType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "varName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "searchSchema", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "df", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new rdf_js_1.DataFactory({
                blankNodePrefix: "b",
            })
        });
        Object.defineProperty(this, "sparqlValues", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        this.property = property;
        this.propertyType = property["@type"] ? property["@type"] : xsd_js_1.xsd.string;
        this.varName = varName;
        this.searchSchema = this.isPlainObject(searchSchema)
            ? searchSchema
            : { $equals: searchSchema };
    }
    process() {
        this.processOperators();
        this.processStringFunctions();
        this.processRegex();
        this.processLangMatches();
        this.processArrayFunctions();
        this.processFilter();
    }
    processOperators() {
        const map = {
            $equals: "=",
            $not: "!=",
            $gt: ">",
            $gte: ">=",
            $lt: "<",
            $lte: "<=",
        };
        for (const [key, operator] of Object.entries(map)) {
            const value = this.searchSchema[key];
            if (value === undefined) {
                continue;
            }
            this.addFilter((0, mod_js_1.sparql) `${this.df.variable(this.varName)} ${operator} ${this.encode(value)}`);
        }
    }
    processStringFunctions() {
        const map = {
            $contains: "CONTAINS",
            $strStarts: "STRSTARTS",
            $strEnds: "STRENDS",
        };
        for (const [key, func] of Object.entries(map)) {
            const value = this.searchSchema[key];
            if (value === undefined) {
                continue;
            }
            this.addFilter((0, mod_js_1.sparql) `${func}(${this.df.variable(this.varName)}, ${this.encode(value)})`);
        }
    }
    processRegex() {
        const value = this.searchSchema.$regex;
        if (value === undefined) {
            return;
        }
        this.addFilter((0, mod_js_1.sparql) `REGEX(${this.df.variable(this.varName)}, "${value}")`);
    }
    processLangMatches() {
        const value = this.searchSchema.$langMatches;
        if (value === undefined) {
            return;
        }
        this.addFilter((0, mod_js_1.sparql) `LANGMATCHES(LANG(${this.df.variable(this.varName)}), "${value}")`);
    }
    processArrayFunctions() {
        const map = {
            $in: "IN",
            $notIn: "NOT IN",
        };
        for (const [key, func] of Object.entries(map)) {
            const value = this.searchSchema[key];
            if (value === undefined) {
                continue;
            }
            const values = value.map((v) => (0, mod_js_1.sparql) `${this.encode(v)}`);
            this.addFilter((0, mod_js_1.sparql) `${this.df.variable(this.varName)} ${func} (${values.join(", ")})`);
        }
    }
    processFilter() {
        const value = this.searchSchema.$filter;
        if (value === undefined) {
            return;
        }
        const stringified = (0, mod_js_1.sparql) `${value}`;
        this.addFilter(stringified.replace("?value", `?${this.varName}`));
    }
    addFilter(filter) {
        this.sparqlValues.push((0, mod_js_1.sparql) `FILTER (${filter}) .`);
    }
    encode(value) {
        return (0, encoder_js_1.encodeValue)(value, this.propertyType, this.df);
    }
    isPlainObject(value) {
        if (typeof value !== "object" || value === null) {
            return false;
        }
        const prototype = Object.getPrototypeOf(value);
        return (prototype === null || prototype === Object.prototype ||
            Object.getPrototypeOf(prototype) === null) &&
            !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
    }
}
exports.SearchHelper = SearchHelper;
