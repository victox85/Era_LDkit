"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryEngine = void 0;
const query_resolvers_js_1 = require("./query_resolvers.js");
/**
 * A query engine that can query a SPARQL endpoint.
 *
 * Implements {@link IQueryEngine} interface.
 *
 * This engine is used by default if no other engine is configured.
 * See {@link Options} for more details.
 *
 * If you need to query other data sources, or multiple SPARQL endpoints,
 * you can use [Comunica](https://comunica.dev) instead, extend this engine,
 * or implement your own.
 */
class QueryEngine {
    getSparqlEndpoint(context) {
        if (!context) {
            throw new Error("No context supplied to QueryEngine. You need to create a default context or pass one to a resource.");
        }
        if (!Array.isArray(context.sources) || context.sources.length < 1) {
            throw new Error("Invalid context `sources` attribute defined. You need to provide a URL to a SPARQL endpoint to query.");
        }
        if (context.sources.length > 1) {
            throw new Error("This query engine supports only one data source, multiple defined in `sources` property in context.");
        }
        const source = context.sources[0];
        if (typeof source === "string") {
            return source;
        }
        if ("value" in source && typeof source.value === "string") {
            if ("type" in source) {
                if (source.type === "sparql") {
                    return source.value;
                }
            }
            else {
                return source.value;
            }
        }
        throw new Error("Invalid SPARQL source defined - please provide URL to a SPARQL endpoint to query.");
    }
    getFetch(context) {
        return context && context.fetch ? context.fetch : fetch;
    }
    query(body, requestType, responseType, context) {
        const endpoint = this.getSparqlEndpoint(context);
        const fetchFn = this.getFetch(context);
        return fetchFn(endpoint, {
            method: "POST",
            headers: {
                "accept": responseType,
                "content-type": `${requestType}; charset=UTF-8`,
            },
            body,
        });
    }
    async queryAndResolve(type, query, context) {
        const responseType = (0, query_resolvers_js_1.getResponseTypes)(type).join(", ");
        const response = await this.query(query, "application/sparql-query", responseType, context);
        if (!response.ok) {
            await response.body?.cancel();
            throw new Error(`Invalid query response status '${response.status} ${response.statusText}'`);
        }
        return (0, query_resolvers_js_1.resolve)(type, response);
    }
    /**
     * Executes a SPARQL SELECT query and returns a stream of bindings.
     *
     * @param query SPARQL query string
     * @param context Engine context
     * @returns Stream of bindings
     */
    queryBindings(query, context) {
        return this.queryAndResolve("bindings", query, context);
    }
    /**
     * Executes a SPARQL ASK query and returns a boolean result.
     *
     * @param query SPARQL query string
     * @param context Engine context
     * @returns Boolean result
     */
    queryBoolean(query, context) {
        return this.queryAndResolve("boolean", query, context);
    }
    /**
     * Executes a SPARQL CONSTRUCT query and returns a stream of quads.
     *
     * @param query SPARQL query string
     * @param context Engine context
     * @returns Stream of quads
     */
    queryQuads(query, context) {
        return this.queryAndResolve("quads", query, context);
    }
    /**
     * Executes a SPARQL UPDATE query and returns nothing.
     *
     * @param query SPARQL query string
     * @param context Engine context
     * @returns Nothing
     */
    async queryVoid(query, context) {
        await this.query(query, "application/sparql-update", "application/sparql-results+json", context);
    }
}
exports.QueryEngine = QueryEngine;
