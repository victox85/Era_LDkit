"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolve = exports.getResponseTypes = void 0;
const utils_js_1 = require("../utils.js");
const rdf_js_1 = require("../rdf.js");
const asynciterator_js_1 = require("../asynciterator.js");
class QueryResolver {
}
class BooleanJsonResolver extends QueryResolver {
    async resolve(response) {
        const json = await response.json();
        if ("boolean" in json) {
            return Boolean(json.boolean);
        }
        throw new Error("Boolean SPARQL query result not found");
    }
}
class BindingsJsonResolver extends QueryResolver {
    async resolve(response) {
        const json = await response.json();
        if (!Array.isArray(json.results?.bindings)) {
            throw new Error("Bindings SPARQL query result not found");
        }
        const bindingsFactory = new rdf_js_1.BindingsFactory();
        const bindingsIterator = new asynciterator_js_1.ArrayIterator(json.results.bindings);
        return new asynciterator_js_1.MappingIterator(bindingsIterator, (i) => bindingsFactory.fromJson(i));
    }
}
class QuadsJsonResolver extends QueryResolver {
    async resolve(response) {
        const json = await response.json();
        if (!(json?.constructor === Object)) {
            throw new Error("Quads SPARQL query result not found");
        }
        const quadFactory = new rdf_js_1.QuadFactory();
        const treeIterator = new asynciterator_js_1.TreeIterator(json);
        return new asynciterator_js_1.MappingIterator(treeIterator, (i) => quadFactory.fromJson(i));
    }
}
const createN3Stream = async (response, format) => {
    if (response.body === null) {
        throw new Error("Response body is null, but it should contain quads from the SPARQL query");
    }
    const stream = (0, utils_js_1.readableFromWeb)(response.body);
    const parser = new rdf_js_1.N3.StreamParser({ format });
    return await parser.import(stream);
};
class QuadsNTriplesResolver extends QueryResolver {
    resolve(response) {
        return createN3Stream(response, "N-Triples");
    }
}
class QuadsNQuadsResolver extends QueryResolver {
    resolve(response) {
        return createN3Stream(response, "N-Quads");
    }
}
class QuadsTurtleResolver extends QueryResolver {
    resolve(response) {
        return createN3Stream(response, "Turtle");
    }
}
class QuadsTrigResolver extends QueryResolver {
    resolve(response) {
        return createN3Stream(response, "TriG");
    }
}
const resolvers = {
    "boolean": {
        "application/sparql-results+json": new BooleanJsonResolver(),
    },
    "bindings": {
        "application/sparql-results+json": new BindingsJsonResolver(),
    },
    "quads": {
        "application/rdf+json": new QuadsJsonResolver(),
        "application/n-triples": new QuadsNTriplesResolver(),
        "application/n-quads": new QuadsNQuadsResolver(),
        "text/turtle": new QuadsTurtleResolver(),
        "application/trig": new QuadsTrigResolver(),
    },
};
const getResponseTypes = (resolverType) => Object.keys(resolvers[resolverType]);
exports.getResponseTypes = getResponseTypes;
const resolve = (resolverType, response) => {
    const contentType = response.headers.get("Content-type");
    if (!contentType) {
        throw new Error(`Content-type header was not found in response`);
    }
    const separatorPosition = contentType.indexOf(";");
    const mime = separatorPosition > 0
        ? contentType.substring(0, separatorPosition)
        : contentType;
    const resolver = resolvers[resolverType][mime];
    if (!resolver) {
        throw new Error(`No resolver exists for response type '${mime}'`);
    }
    return resolver.resolve(response);
};
exports.resolve = resolve;
