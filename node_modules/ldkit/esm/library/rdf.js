export { fromRdf, toRdf } from "rdf-literal";
import { quadToStringQuad } from "rdf-string";
import { DataFactory, DefaultGraph } from "rdf-data-factory";
export { DataFactory, DefaultGraph };
export * as N3 from "n3";
export const quadsToGraph = (quadStream) => {
    return new Promise((resolve, reject) => {
        const graph = new Map();
        const included = {};
        quadStream.on("data", (quad) => {
            const hash = Object.values(quadToStringQuad(quad)).join(" ");
            if (included[hash]) {
                return;
            }
            included[hash] = true;
            const s = quad.subject.value;
            const p = quad.predicate.value;
            const predicateMap = graph.get(s) || graph.set(s, new Map()).get(s);
            const termArray = predicateMap.get(p) || predicateMap.set(p, []).get(p);
            termArray.push(quad.object);
        });
        quadStream.on("end", () => resolve(graph));
        quadStream.on("error", reject);
    });
};
export class TermFactory {
    constructor(dataFactory = new DataFactory()) {
        Object.defineProperty(this, "dataFactory", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.dataFactory = dataFactory;
    }
    fromJson(jsonTerm) {
        if (jsonTerm.type === "uri") {
            return this.dataFactory.namedNode(jsonTerm.value);
        }
        if (jsonTerm.type === "bnode") {
            return this.dataFactory.blankNode(jsonTerm.value);
        }
        if ("lang" in jsonTerm) {
            return this.dataFactory.literal(jsonTerm.value, jsonTerm["lang"]);
        }
        if ("datatype" in jsonTerm) {
            return this.dataFactory.literal(jsonTerm.value, this.dataFactory.namedNode(jsonTerm.datatype));
        }
        return this.dataFactory.literal(jsonTerm.value);
    }
}
export class ReadOnlyBindings {
    constructor(bindings, dataFactory = new DataFactory()) {
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "bindings"
        });
        Object.defineProperty(this, "dataFactory", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "entries", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "variables", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.entries = bindings;
        this.dataFactory = dataFactory;
        this.variables = new Map();
        for (const variable of bindings.keys()) {
            this.variables.set(variable.value, variable);
        }
    }
    has(key) {
        const stringKey = typeof key === "string" ? key : key.value;
        const variableKey = this.variables.get(stringKey);
        return this.entries.has(variableKey);
    }
    get(key) {
        const stringKey = typeof key === "string" ? key : key.value;
        const variableKey = this.variables.get(stringKey);
        return this.entries.get(variableKey);
    }
    set(_key, _value) {
        throw new Error("Method not implemented.");
    }
    delete(_key) {
        throw new Error("Method not implemented.");
    }
    keys() {
        return this.entries.keys();
    }
    values() {
        return this.entries.values();
    }
    forEach(fn) {
        return this.entries.forEach(fn);
    }
    get size() {
        return this.entries.size;
    }
    [Symbol.iterator]() {
        return this.entries.entries();
    }
    equals(_other) {
        throw new Error("Method not implemented.");
    }
    filter(_fn) {
        throw new Error("Method not implemented.");
    }
    map(_fn) {
        throw new Error("Method not implemented.");
    }
    merge(_other) {
        throw new Error("Method not implemented.");
    }
    mergeWith(_merger, _other) {
        throw new Error("Method not implemented.");
    }
}
export class BindingsFactory {
    constructor(dataFactory = new DataFactory(), termFactory = new TermFactory(dataFactory)) {
        Object.defineProperty(this, "dataFactory", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "termFactory", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.dataFactory = dataFactory;
        this.termFactory = termFactory;
    }
    fromJson(jsonBindings) {
        const bindingsEntries = Object.entries(jsonBindings).map(([varName, jsonTerm]) => {
            return [
                this.dataFactory.variable(varName),
                this.termFactory.fromJson(jsonTerm),
            ];
        });
        return new ReadOnlyBindings(new Map(bindingsEntries), this.dataFactory);
    }
}
export class QuadFactory {
    constructor(dataFactory = new DataFactory(), termFactory = new TermFactory(dataFactory)) {
        Object.defineProperty(this, "dataFactory", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "termFactory", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.dataFactory = dataFactory;
        this.termFactory = termFactory;
    }
    fromJson(jsonRdf) {
        const [s, p, o] = jsonRdf;
        return this.dataFactory.quad(this.dataFactory.namedNode(s), this.dataFactory.namedNode(p), this.termFactory.fromJson(o));
    }
}
