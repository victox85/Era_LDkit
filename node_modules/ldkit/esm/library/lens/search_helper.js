import { DataFactory } from "../rdf.js";
import { sparql as $ } from "../sparql/mod.js";
import { encodeValue } from "../encoder.js";
import { xsd } from "../../namespaces/xsd.js";
export class SearchHelper {
    constructor(property, varName, searchSchema) {
        Object.defineProperty(this, "property", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "propertyType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "varName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "searchSchema", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "df", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new DataFactory({
                blankNodePrefix: "b",
            })
        });
        Object.defineProperty(this, "sparqlValues", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        this.property = property;
        this.propertyType = property["@type"] ? property["@type"] : xsd.string;
        this.varName = varName;
        this.searchSchema = this.isPlainObject(searchSchema)
            ? searchSchema
            : { $equals: searchSchema };
    }
    process() {
        this.processOperators();
        this.processStringFunctions();
        this.processRegex();
        this.processLangMatches();
        this.processArrayFunctions();
        this.processFilter();
    }
    processOperators() {
        const map = {
            $equals: "=",
            $not: "!=",
            $gt: ">",
            $gte: ">=",
            $lt: "<",
            $lte: "<=",
        };
        for (const [key, operator] of Object.entries(map)) {
            const value = this.searchSchema[key];
            if (value === undefined) {
                continue;
            }
            this.addFilter($ `${this.df.variable(this.varName)} ${operator} ${this.encode(value)}`);
        }
    }
    processStringFunctions() {
        const map = {
            $contains: "CONTAINS",
            $strStarts: "STRSTARTS",
            $strEnds: "STRENDS",
        };
        for (const [key, func] of Object.entries(map)) {
            const value = this.searchSchema[key];
            if (value === undefined) {
                continue;
            }
            this.addFilter($ `${func}(${this.df.variable(this.varName)}, ${this.encode(value)})`);
        }
    }
    processRegex() {
        const value = this.searchSchema.$regex;
        if (value === undefined) {
            return;
        }
        this.addFilter($ `REGEX(${this.df.variable(this.varName)}, "${value}")`);
    }
    processLangMatches() {
        const value = this.searchSchema.$langMatches;
        if (value === undefined) {
            return;
        }
        this.addFilter($ `LANGMATCHES(LANG(${this.df.variable(this.varName)}), "${value}")`);
    }
    processArrayFunctions() {
        const map = {
            $in: "IN",
            $notIn: "NOT IN",
        };
        for (const [key, func] of Object.entries(map)) {
            const value = this.searchSchema[key];
            if (value === undefined) {
                continue;
            }
            const values = value.map((v) => $ `${this.encode(v)}`);
            this.addFilter($ `${this.df.variable(this.varName)} ${func} (${values.join(", ")})`);
        }
    }
    processFilter() {
        const value = this.searchSchema.$filter;
        if (value === undefined) {
            return;
        }
        const stringified = $ `${value}`;
        this.addFilter(stringified.replace("?value", `?${this.varName}`));
    }
    addFilter(filter) {
        this.sparqlValues.push($ `FILTER (${filter}) .`);
    }
    encode(value) {
        return encodeValue(value, this.propertyType, this.df);
    }
    isPlainObject(value) {
        if (typeof value !== "object" || value === null) {
            return false;
        }
        const prototype = Object.getPrototypeOf(value);
        return (prototype === null || prototype === Object.prototype ||
            Object.getPrototypeOf(prototype) === null) &&
            !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
    }
}
