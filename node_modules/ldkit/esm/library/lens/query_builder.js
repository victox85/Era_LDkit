import { getSchemaProperties, } from "../schema/mod.js";
import { CONSTRUCT, DELETE, INSERT, SELECT, sparql as $, } from "../sparql/mod.js";
import { DataFactory } from "../rdf.js";
import { ldkit } from "../../namespaces/ldkit.js";
import { rdf } from "../../namespaces/rdf.js";
import { encode } from "../encoder.js";
import { UpdateHelper } from "./update_helper.js";
import { SearchHelper } from "./search_helper.js";
var Flags;
(function (Flags) {
    Flags[Flags["None"] = 0] = "None";
    Flags[Flags["ExcludeOptional"] = 1] = "ExcludeOptional";
    Flags[Flags["UnwrapOptional"] = 2] = "UnwrapOptional";
    Flags[Flags["IncludeTypes"] = 4] = "IncludeTypes";
    Flags[Flags["IgnoreInverse"] = 8] = "IgnoreInverse";
})(Flags || (Flags = {}));
export class QueryBuilder {
    constructor(schema, options) {
        Object.defineProperty(this, "schema", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "df", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "deleteQuery", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (iris) => {
                return DELETE `
      ?s ?p ?o
    `.WHERE `
      ?s ?p ?o .
      VALUES ?s { ${iris.map(this.df.namedNode)} }
    `.build();
            }
        });
        this.schema = schema;
        this.options = options;
        this.df = new DataFactory();
    }
    getResourceSignature() {
        return this.df.quad(this.df.variable("iri"), this.df.namedNode(rdf.type), this.df.namedNode(ldkit.Resource));
    }
    entitiesToQuads(entities) {
        const quadArrays = entities.map((entity) => encode(entity, this.schema, this.options));
        return [].concat(...quadArrays);
    }
    getShape(flags, searchSchema) {
        const includeOptional = (flags & Flags.ExcludeOptional) === 0;
        const wrapOptional = (flags & Flags.UnwrapOptional) === 0;
        const omitRootTypes = (flags & Flags.IncludeTypes) === 0;
        const ignoreInverse = (flags & Flags.IgnoreInverse) === Flags.IgnoreInverse;
        const mainVar = "iri";
        const conditions = [];
        const populateSearchConditions = (property, varName, search) => {
            if (search === undefined) {
                return;
            }
            const helper = new SearchHelper(property, varName, search);
            helper.process();
            conditions.push(helper.sparqlValues);
        };
        const populateConditionsRecursive = (s, varPrefix, search) => {
            const rdfType = s["@type"];
            const properties = getSchemaProperties(s);
            if (varPrefix !== "iri" || !omitRootTypes) {
                rdfType.forEach((type) => {
                    conditions.push(this.df.quad(this.df.variable(varPrefix), this.df.namedNode(rdf.type), this.df.namedNode(type)));
                });
            }
            Object.keys(properties).forEach((prop, index) => {
                const property = properties[prop];
                const isOptional = property["@optional"];
                const propertySchema = search?.[prop];
                if (!includeOptional && isOptional && propertySchema === undefined) {
                    return;
                }
                if (wrapOptional && isOptional) {
                    conditions.push($ `\nOPTIONAL {`);
                }
                const isInverse = property["@inverse"];
                if (ignoreInverse || !isInverse) {
                    conditions.push(this.df.quad(this.df.variable(varPrefix), this.df.namedNode(property["@id"]), this.df.variable(`${varPrefix}_${index}`)));
                    populateSearchConditions(property, `${varPrefix}_${index}`, propertySchema);
                }
                else {
                    conditions.push(this.df.quad(this.df.variable(`${varPrefix}_${index}`), this.df.namedNode(property["@id"]), this.df.variable(varPrefix)));
                }
                if (typeof property["@schema"] === "object") {
                    populateConditionsRecursive(property["@schema"], `${varPrefix}_${index}`, propertySchema);
                }
                if (wrapOptional && isOptional) {
                    conditions.push($ `\n}\n`);
                }
            });
        };
        populateConditionsRecursive(this.schema, mainVar, searchSchema);
        return conditions;
    }
    countQuery(where, max) {
        const quads = this.getShape(Flags.ExcludeOptional | Flags.IncludeTypes, where);
        const innerQuery = max === undefined
            ? quads
            : SELECT `?iri`.WHERE `${quads}`.LIMIT(max);
        return SELECT `(COUNT(DISTINCT ?iri) as ?count)`.WHERE `${innerQuery}`
            .build();
    }
    getQuery(where, limit, offset) {
        const selectSubQuery = SELECT.DISTINCT `
      ${this.df.variable("iri")}
    `.WHERE `
      ${this.getShape(Flags.ExcludeOptional | Flags.IncludeTypes)} 
      ${where}
    `.LIMIT(limit).OFFSET(offset).build();
        const query = CONSTRUCT `
      ${this.getResourceSignature()}
      ${this.getShape(Flags.UnwrapOptional | Flags.IgnoreInverse)}
    `.WHERE `
      {
        ${selectSubQuery}
      }
      ${this.getShape(Flags.None)}
    `.build();
        return query;
    }
    getSearchQuery(where, limit, offset) {
        if (where.$id) {
            const ids = Array.isArray(where.$id) ? where.$id : [where.$id];
            return this.getByIrisQuery(ids, where);
        }
        const selectSubQuery = SELECT.DISTINCT `
      ${this.df.variable("iri")}
    `.WHERE `
      ${this.getShape(Flags.ExcludeOptional | Flags.IncludeTypes, where)} 
    `.LIMIT(limit).OFFSET(offset).build();
        const query = CONSTRUCT `
      ${this.getResourceSignature()}
      ${this.getShape(Flags.UnwrapOptional | Flags.IgnoreInverse)}
    `.WHERE `
      {
        ${selectSubQuery}
      }
      ${this.getShape(Flags.None, where)}
    `.build();
        return query;
    }
    getByIrisQuery(iris, where) {
        const query = CONSTRUCT `
      ${this.getResourceSignature()}
      ${this.getShape(Flags.UnwrapOptional | Flags.IgnoreInverse)}
    `.WHERE `
      VALUES ?iri {
        ${iris.map(this.df.namedNode)}
      }
      ${this.getShape(Flags.IncludeTypes, where)}
    `.build();
        return query;
    }
    insertQuery(entities) {
        const quads = this.entitiesToQuads(entities);
        return this.insertDataQuery(quads);
    }
    insertDataQuery(quads) {
        return INSERT.DATA `${quads}`.build();
    }
    deleteDataQuery(quads) {
        return DELETE.DATA `${quads}`.build();
    }
    updateQuery(entities) {
        const helper = new UpdateHelper(this.schema, this.options);
        for (const entity of entities) {
            helper.process(entity);
        }
        return DELETE `${helper.deleteQuads}`.INSERT `${helper.insertQuads}`
            .WHERE `${helper.whereQuads}`.build();
    }
}
