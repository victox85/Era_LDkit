import type * as RDF from "@rdfjs/types";
export type { RDF };
export { fromRdf, toRdf } from "rdf-literal";
import { DataFactory, DefaultGraph } from "rdf-data-factory";
export { DataFactory, DefaultGraph };
export * as N3 from "n3";
export type IRI = string;
export type Node = Map<IRI, RDF.Term[]>;
export type Graph = Map<IRI, Node>;
export declare const quadsToGraph: (quadStream: RDF.ResultStream<RDF.Quad>) => Promise<Graph>;
export declare namespace RDFJSON {
    type Term = {
        type: "uri" | "literal" | "bnode";
        value: string;
        lang?: string;
        datatype?: string;
    };
    type Bindings = Record<string, Term>;
    type Triple = [IRI, IRI, Term];
    type SparqlResultsJsonFormat = {
        head: {
            vars?: string[];
        };
        results?: {
            bindings: Bindings[];
        };
        boolean?: boolean;
    };
    type RdfJsonFormat = Record<IRI, Record<IRI, Term[]>>;
    interface TermFactory {
        fromJson(jsonTerm: Term): RDF.Term;
    }
    interface BindingsFactory {
        fromJson(jsonBindings: Bindings): RDF.Bindings;
    }
    interface QuadFactory {
        fromJson(jsonRdf: Triple): RDF.Quad;
    }
}
export declare class TermFactory implements RDFJSON.TermFactory {
    protected readonly dataFactory: RDF.DataFactory;
    constructor(dataFactory?: RDF.DataFactory);
    fromJson(jsonTerm: RDFJSON.Term): RDF.BlankNode | RDF.Literal | RDF.NamedNode<string>;
}
export declare class ReadOnlyBindings implements RDF.Bindings {
    readonly type = "bindings";
    protected readonly dataFactory: RDF.DataFactory;
    protected readonly entries: Map<RDF.Variable, RDF.Term>;
    protected readonly variables: Map<string, RDF.Variable>;
    constructor(bindings: Map<RDF.Variable, RDF.Term>, dataFactory?: RDF.DataFactory);
    has(key: string | RDF.Variable): boolean;
    get(key: string | RDF.Variable): RDF.Term | undefined;
    set(_key: string | RDF.Variable, _value: RDF.Term): RDF.Bindings;
    delete(_key: string | RDF.Variable): RDF.Bindings;
    keys(): MapIterator<RDF.Variable>;
    values(): MapIterator<RDF.Term>;
    forEach(fn: (value: RDF.Term, key: RDF.Variable) => unknown): void;
    get size(): number;
    [Symbol.iterator](): MapIterator<[RDF.Variable, RDF.Term]>;
    equals(_other: RDF.Bindings | null | undefined): boolean;
    filter(_fn: (value: RDF.Term, key: RDF.Variable) => boolean): RDF.Bindings;
    map(_fn: (value: RDF.Term, key: RDF.Variable) => RDF.Term): RDF.Bindings;
    merge(_other: RDF.Bindings): RDF.Bindings | undefined;
    mergeWith(_merger: (self: RDF.Term, other: RDF.Term, key: RDF.Variable) => RDF.Term, _other: RDF.Bindings): RDF.Bindings;
}
export declare class BindingsFactory implements RDFJSON.BindingsFactory {
    protected readonly dataFactory: RDF.DataFactory;
    protected readonly termFactory: RDFJSON.TermFactory;
    constructor(dataFactory?: RDF.DataFactory, termFactory?: RDFJSON.TermFactory);
    fromJson(jsonBindings: RDFJSON.Bindings): ReadOnlyBindings;
}
export declare class QuadFactory implements RDFJSON.QuadFactory {
    protected readonly dataFactory: RDF.DataFactory;
    protected readonly termFactory: RDFJSON.TermFactory;
    constructor(dataFactory?: RDF.DataFactory, termFactory?: RDFJSON.TermFactory);
    fromJson(jsonRdf: [IRI, IRI, RDFJSON.Term]): RDF.Quad;
}
//# sourceMappingURL=rdf.d.ts.map