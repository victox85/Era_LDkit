import { rdf } from "../../namespaces/rdf.js";
import { xsd } from "../../namespaces/xsd.js";
export const expandSchema = (schemaPrototype) => {
    if (typeof schemaPrototype !== "object") {
        throw new Error(`Invalid schema, expected object`);
    }
    if (Object.keys(schemaPrototype).length === 0) {
        throw new Error(`Invalid schema, empty object, expected "@type" key or property definition`);
    }
    const expandShortcut = (value) => {
        return value === "@type" ? rdf.type : value;
    };
    const expandArray = (stringOrStrings) => {
        return Array.isArray(stringOrStrings) ? stringOrStrings : [stringOrStrings];
    };
    const expandSchemaProperty = (stringOrProperty) => {
        if (typeof stringOrProperty === "string") {
            return {
                "@id": expandShortcut(stringOrProperty),
                "@type": xsd.string,
            };
        }
        const property = stringOrProperty;
        if (!property["@id"]) {
            throw new Error(`Invalid schema, "@id" key for property missing`);
        }
        if (property["@inverse"] && property["@multilang"]) {
            throw new Error(`Invalid schema, "@inverse" property cannot be used with "@multilang"`);
        }
        const validKeys = [
            "@schema",
            "@id",
            "@type",
            "@array",
            "@optional",
            "@multilang",
            "@inverse",
        ];
        const baseProperty = {
            "@id": "",
        };
        const expandedProperty = Object.keys(property).reduce((acc, key) => {
            if (key === "@schema") {
                acc[key] = expandSchema(property[key]);
            }
            else if (key === "@id") {
                acc[key] = expandShortcut(property[key]);
            }
            else if (validKeys.includes(key)) {
                acc[key] = property[key];
            }
            return acc;
        }, baseProperty);
        if (!baseProperty["@type"] && !baseProperty["@schema"]) {
            baseProperty["@type"] = xsd.string;
        }
        return expandedProperty;
    };
    const baseSchema = {
        "@type": [],
    };
    const existingPropertyMap = {};
    return Object.keys(schemaPrototype).reduce((acc, key) => {
        if (key === "@type") {
            acc[key] = expandArray(schemaPrototype[key]);
        }
        else {
            const expandedProperty = expandSchemaProperty(schemaPrototype[key]);
            if (existingPropertyMap[expandedProperty["@id"]]) {
                throw new Error(`Invalid schema, duplicate property "${expandedProperty["@id"]}"`);
            }
            else {
                existingPropertyMap[expandedProperty["@id"]] = true;
            }
            acc[key] = expandedProperty;
        }
        return acc;
    }, baseSchema);
};
export const getSchemaProperties = (schema) => {
    const { "@type": _ommitedType, ...properties } = schema;
    return properties;
};
