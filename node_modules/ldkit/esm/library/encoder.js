import { DataFactory } from "./rdf.js";
import { xsd } from "../namespaces/xsd.js";
import { rdf } from "../namespaces/rdf.js";
import { ldkit } from "../namespaces/ldkit.js";
import { translateToRdf } from "./translator.js";
export const encode = (node, schema, options, includeType = true, variableInitCounter = 0) => {
    return Encoder.encode(node, schema, options, includeType, variableInitCounter);
};
export const encodeValue = (value, datatype, df) => {
    if (datatype === ldkit.IRI) {
        return df.namedNode(value);
    }
    return translateToRdf(value, datatype);
};
class Encoder {
    constructor(options, includeType, variableInitCounter) {
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "includeType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "df", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new DataFactory({
                blankNodePrefix: "b",
            })
        });
        Object.defineProperty(this, "variableCounter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "output", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        this.options = options;
        this.includeType = includeType;
        this.variableCounter = variableInitCounter;
    }
    static encode(node, schema, options, includeType, variableInitCounter) {
        return new Encoder(options, includeType, variableInitCounter).encode(node, schema);
    }
    encode(node, schema) {
        const nodeId = this.getNodeId(node);
        this.encodeNode(node, schema, nodeId);
        return this.output;
    }
    push(s, p, o) {
        this.output.push(this.df.quad(s, p, o));
    }
    getNodeId(node) {
        return node.$id
            ? this.df.namedNode(node.$id)
            : this.df.blankNode();
    }
    getNodeTypes(node) {
        if (Array.isArray(node.$type)) {
            return node.$type;
        }
        return node.$type ? [node.$type] : [];
    }
    encodeNode(node, schema, nodeId) {
        if (this.includeType) {
            this.encodeNodeType(node, schema["@type"], nodeId);
        }
        Object.keys(schema).forEach((key) => {
            if (key === "@type") {
                return;
            }
            this.encodeNodeProperty(node[key], schema[key], nodeId);
        });
    }
    encodeNodeType(node, requiredTypes, nodeId) {
        const finalTypes = new Set([...this.getNodeTypes(node), ...requiredTypes]);
        finalTypes.forEach((type) => {
            this.push(nodeId, this.df.namedNode(rdf.type), this.df.namedNode(type));
        });
    }
    encodeNodeProperty(value, property, nodeId) {
        if (value === undefined) {
            return;
        }
        const propertyId = this.df.namedNode(property["@id"]);
        if (value === null) {
            // TODO
            this.push(nodeId, propertyId, this.df.variable(`v${this.variableCounter++}`));
            return;
        }
        if (property["@multilang"]) {
            const multiValue = value;
            Object.keys(multiValue).forEach((language) => {
                const languageValue = Array.isArray(multiValue[language])
                    ? multiValue[language]
                    : [multiValue[language]];
                languageValue.forEach((singleValue) => {
                    this.push(nodeId, propertyId, this.df.literal(singleValue, language.length > 0 ? language : undefined));
                });
            });
            return;
        }
        const values = Array.isArray(value) ? value : [value];
        values.forEach((val) => {
            if (property["@schema"]) {
                const subNodeId = this.getNodeId(val);
                this.encodeNode(val, property["@schema"], subNodeId);
                this.push(nodeId, propertyId, subNodeId);
                return;
            }
            const propertyType = property["@type"] ? property["@type"] : xsd.string;
            if (typeof val === "string" && this.options.language) {
                if (propertyType === xsd.string || propertyType === rdf.langString) {
                    this.push(nodeId, propertyId, this.df.literal(val, this.options.language));
                    return;
                }
            }
            const rdfValue = encodeValue(val, propertyType, this.df);
            this.push(nodeId, propertyId, rdfValue);
        });
    }
}
